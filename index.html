<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Text to Sound Communication</title>
</head>
<body>
  <textarea id="textInput" placeholder="Enter text to transmit"></textarea>
  <button onclick="transmit()">Transmit</button>
  <div id="receiver"></div>

  <script>
    // Object to store character to frequency mapping
    var charFrequencyMap = {
      'a': 500,
      'b': 600,
      'c': 700,
      'd': 800,
      'e': 900,
      'f': 1000,
      'g': 1100,
      'h': 1200,
      'i': 1300,
      'j': 1400,
      'k': 1500,
      'l': 1600,
      'm': 1700,
      'n': 1800,
      'o': 1900,
      'p': 2000,
      'q': 2100,
      'r': 2200,
      's': 2300,
      't': 2400,
      'u': 2500,
      'v': 2600,
      'w': 2700,
      'x': 2800,
      'y': 2900,
      'z': 3000,
      ' ': 3100, // space character
      // Add more characters if needed
    };

    function transmit() {
      var text = document.getElementById('textInput').value.toLowerCase(); // Convert text to lowercase for simplicity
      var encoded = textToSignal(text);
      playSound(encoded);
    }

    function textToSignal(text) {
      // Convert text to a signal
      var signal = [];
      for (var i = 0; i < text.length; i++) {
        var char = text.charAt(i);
        if (char in charFrequencyMap) {
          signal.push(charFrequencyMap[char]);
        }
      }
      return signal;
    }

    function playSound(signal) {
      var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      var oscillator = audioCtx.createOscillator();
      var gainNode = audioCtx.createGain();
      
      oscillator.type = 'sine';
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      
      var time = 0.5; // Duration of each character (in seconds)
      
      for (var i = 0; i < signal.length; i++) {
        oscillator.frequency.setValueAtTime(signal[i], audioCtx.currentTime + i * time);
        gainNode.gain.setValueAtTime(1, audioCtx.currentTime + i * time);
      }

      oscillator.start();
      oscillator.stop(audioCtx.currentTime + time * signal.length);
    }

    // Receiver side (decoding)
    var receiverDiv = document.getElementById('receiver');
    var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    var analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    var dataArray = new Uint8Array(analyser.frequencyBinCount);
    var lastTime = 0;

    navigator.mediaDevices.getUserMedia({ audio: true })
      .then(function(stream) {
        var source = audioCtx.createMediaStreamSource(stream);
        source.connect(analyser);
        setInterval(function(){
          analyser.getByteFrequencyData(dataArray);
          decodeSignal(dataArray);
        }, 100);
      })
      .catch(function(err) {
        console.log('The following error occurred: ' + err);
      });

    function decodeSignal(signal) {
      // Get dominant frequency
      var maxIndex = 0;
      var maxValue = -Infinity;
      for (var i = 0; i < signal.length; i++) {
        if (signal[i] > maxValue) {
          maxIndex = i;
          maxValue = signal[i];
        }
      }
      var dominantFrequency = maxIndex * audioCtx.sampleRate / analyser.fftSize;

      // Find the character with the closest frequency
      var closestChar = findClosestFrequencyChar(dominantFrequency);
      if (closestChar !== null) {
        receiverDiv.innerHTML += closestChar;
      }
    }

    function findClosestFrequencyChar(frequency) {
      for (var char in charFrequencyMap) {
        if (charFrequencyMap[char] === frequency) {
          return char;
        }
      }
      return null;
    }
  </script>
</body>
</html>
