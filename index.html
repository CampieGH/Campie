<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Text to Sound Communication</title>
</head>
<body>
  <textarea id="textInput" placeholder="Enter text to transmit"></textarea>
  <button onclick="transmit()">Transmit</button>
  <div id="receiver"></div>

  <script>
    // Object to store character to frequency mapping
    var charFrequencyMap = {
      'a': 500,
      'b': 600,
      'c': 700,
      'd': 800,
      'e': 900,
      'f': 1000,
      'g': 1100,
      'h': 1200,
      'i': 1300,
      'j': 1400,
      'k': 1500,
      'l': 1600,
      'm': 1700,
      'n': 1800,
      'o': 1900,
      'p': 2000,
      'q': 2100,
      'r': 2200,
      's': 2300,
      't': 2400,
      'u': 2500,
      'v': 2600,
      'w': 2700,
      'x': 2800,
      'y': 2900,
      'z': 3000,
      ' ': 3100, // space character
      // Add more characters if needed
    };

    function transmit() {
      var text = document.getElementById('textInput').value.toLowerCase(); // Convert text to lowercase for simplicity
      var encoded = textToSignal(text);
      playSound(encoded);
    }

    function textToSignal(text) {
      // Convert text to a signal
      var signal = [];
      for (var i = 0; i < text.length; i++) {
        var char = text.charAt(i);
        if (char in charFrequencyMap) {
          signal.push(charFrequencyMap[char]);
        }
      }
      return signal;
    }

    function playSound(signal) {
      var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      var oscillator = audioCtx.createOscillator();
      var gainNode = audioCtx.createGain();
      
      oscillator.type = 'sine';
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      
      var time = 0.5; // Duration of each character (in seconds)
      
      for (var i = 0; i < signal.length; i++) {
        oscillator.frequency.setValueAtTime(signal[i], audioCtx.currentTime + i * time);
        gainNode.gain.setValueAtTime(1, audioCtx.currentTime + i * time);
      }

      oscillator.start();
      oscillator.stop(audioCtx.currentTime + time * signal.length);
    }

    // Receiver side (decoding)
    var receiverDiv = document.getElementById('receiver');
    var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    var scriptNode = audioCtx.createScriptProcessor(2048, 1, 1);
    var bufferSize = 2048;
    var sampleRate = audioCtx.sampleRate;
    var frequencyData = new Uint8Array(bufferSize);
    var frequencyThreshold = 10; // Threshold for frequency matching

    scriptNode.onaudioprocess = function(audioProcessingEvent) {
      var inputBuffer = audioProcessingEvent.inputBuffer;
      var inputData = inputBuffer.getChannelData(0);

      // Calculate FFT
      var fft = new FFT(bufferSize, sampleRate);
      fft.forward(inputData);

      // Get frequency data
      fft.getFrequencyData(frequencyData);

      // Find dominant frequency
      var maxIndex = 0;
      var maxValue = -Infinity;
      for (var i = 0; i < frequencyData.length; i++) {
        if (frequencyData[i] > maxValue) {
          maxIndex = i;
          maxValue = frequencyData[i];
        }
      }
      var dominantFrequency = maxIndex * sampleRate / bufferSize;

      // Find closest character frequency
      var closestChar = findClosestFrequencyChar(dominantFrequency);
      if (closestChar !== null) {
        receiverDiv.innerHTML += closestChar;
      }
    };

    // Connect the script processor node to audio context
    scriptNode.connect(audioCtx.destination);

    function findClosestFrequencyChar(frequency) {
      for (var char in charFrequencyMap) {
        if (Math.abs(charFrequencyMap[char] - frequency) < frequencyThreshold) {
          return char;
        }
      }
      return null;
    }

    // FFT function for frequency analysis
    function FFT(bufferSize, sampleRate) {
      this.bufferSize = bufferSize;
      this.sampleRate = sampleRate;
      this.bandwidth = 2 / bufferSize * (sampleRate / 2);
      this.spectrum = new Float32Array(bufferSize / 2);
      this.real = new Float32Array(bufferSize);
      this.imag = new Float32Array(bufferSize);
      this.peakBand = 0;
      this.peak = 0;
    }

    FFT.prototype.forward = function(buffer) {
      var n = this.bufferSize / 2;
      var spectrum = this.spectrum;
      var real = this.real;
      var imag = this.imag;
      var k = Math.floor(Math.log(n) / Math.LN2);
      var scale = 1 / n;

      this.peak = 0;
      this.peakBand = 0;
      for (var i = 0; i < n; i++) {
        imag[i] = 0;
        real[i] = buffer[i] * scale;
      }

      var halfSize = 1;
      for (var i = 1; i <= k; i++) {
        halfSize *= 2;
        var phaseShiftStepReal = Math.cos(-2 * Math.PI / halfSize);
        var phaseShiftStepImag = Math.sin(-2 * Math.PI / halfSize);
        var currentPhaseShiftReal = 1;
        var currentPhaseShiftImag = 0;
        for (var fftStep = 0; fftStep < halfSize; fftStep++) {
          for (var i = fftStep; i < n; i += halfSize * 2) {
            var off = i + halfSize;
            var tr = (currentPhaseShiftReal * real[off]) - (currentPhaseShiftImag * imag[off]);
            var ti = (currentPhaseShiftReal * imag[off]) + (currentPhaseShiftImag * real[off]);
            real[off] = real[i] - tr;
            imag[off] = imag[i] - ti;
            real[i] += tr;
            imag[i] += ti;
          }
          var tmpReal = currentPhaseShiftReal;
          currentPhaseShiftReal = (tmpReal * phaseShiftStepReal) - (currentPhaseShiftImag * phaseShiftStepImag);
          currentPhaseShiftImag = (tmpReal * phaseShiftStepImag) + (currentPhaseShiftImag * phaseShiftStepReal);
        }
      }

      for (var i = 0; i < n; i++) {
        spectrum[i] = 2 * Math.sqrt(real[i] * real[i] + imag[i] * imag[i]) / n;
        if (spectrum[i] > this.peak) {
          this.peakBand = i;
          this.peak = spectrum[i];
        }
      }
    };

    FFT.prototype.getFrequencyData = function(array) {
      for (var i = 0; i < this.spectrum.length; i++) {
        array[i] = this.spectrum[i];
      }
    };
  </script>
</body>
</html>
